import Ractive from '@ractivejs/core'
import serialize from 'serialize-javascript'
import { parse } from 'acorn'
import { findNodeAfter, base } from 'acorn/dist/walk.es'
import MagicString from 'magic-string'
import deindent from 'de-indent'
import { getSourceMap, offsetMapStart, getInlineSourceMap } from './source-map'

const getComponentsInit = components => `component.exports.components = {${components.map(c => `${c.name}:require('${c.module}')`).join(',')}}`
const getTemplateInit = code => `component.exports.template = ${serialize(Ractive.parse(code))}`
const getStyleInit = code => `component.exports.css = ${serialize(code)}`
const getScriptInit = code => code

const getInit = parts => {
  const sections = []

  if (parts.script) sections.push(getScriptInit(parts.script.code))
  if (parts.components.length) sections.push(getComponentsInit(parts.components))
  if (parts.template) sections.push(getTemplateInit(parts.template.code))
  if (parts.style) sections.push(getStyleInit(parts.style.code))

  return sections
}

const getMap = ({ srcName, destName, script, linesOffset }) => {
  const content = (script && script.code) || ''
  const map = (script && script.map) || getSourceMap({ srcName, destName, content })
  const offset = (script && script.code) ? linesOffset : 0
  return offsetMapStart(map, offset)
}

// TODO: Refactor
const filterExternalComponent = p => p.rel === 'component'  && p.type === 'ractive/component' && p.href
const filterInlineComponent = p => p.rel === 'component' && p.type === 'ractive/component' && p.content
const filterInlineTemplate = p => p.rel === 'template' && p.type === 'ractive/template' && p.content
const filterInlinePartial = p => p.rel === 'partial' && p.type === 'ractive/partial' && p.content
const filterInlineStyle = p => p.rel === 'style' && p.type === 'ractive/style' && p.content

// The loader chooses what builders it imports, Rollup shakes off the excess.
// That's why they can't be in the same function.

// Builders assume all contents necessary for building are already in the parts.
// This means if the loader supports inlining, inlined stuff should already be
// in the parts with content.

// Builders should not be aware of the environment. Anything env-specific should
// be handled by the loader consuming the builder.

// Loaders have the option to implement some or all of the features. (i.e.
// loader may not inline all links)

export const toConstructor = ({ srcName, destName, parts, resolver }) => {
  const component = { exports: {} }

  if (parts.script) {
    const code = parts.script.code
    const map = getInlineSourceMap(getMap(srcName, destName, parts.script, 2))
    // eslint-disable-next-line
    const factory = new Function('require', 'exports', 'component', 'Ractive', `${code}\n${map}`)
    factory(resolver, component.exports, component, Ractive)
  }
  if (parts.components.length) component.exports.components = parts.components.reduce((p, c) => { p[c.name] = resolver(c.module); return p }, {})
  if (parts.template) component.exports.template = Ractive.parse(parts.template.code)
  if (parts.style) component.exports.css = parts.style.code

  return Ractive.extend(component.exports)
}

export const toCJS = ({ srcName, destName, parts }) => {
  const componentParts = parts.filter(filterExternalComponent)
  const templateParts = parts.filter(filterInlineTemplate).slice(0, 1)
  const partialParts = parts.filter(filterInlinePartial)
  const styleParts = parts.filter(filterInlineStyle)
  const scriptParts = parts.filter(filterInlineComponent)

  const sections = []
  sections.push('var Ractive = require(\'@ractivejs/core\')')
  sections.push('var component = {exports:{}}')
  sections.push(...scriptParts.map(s => s.content))
  sections.push(`component.exports.template = ${templateParts.map(t => serialize(Ractive.parse(t.content))).join('')}`)
  sections.push(`component.exports.css = ${styleParts.map(s => serialize(s.content)).join('\n')}`)
  sections.push('component.exports.components = component.exports.components || {}')
  sections.push(`component.exports.components = {${componentParts.map(c => `${c.id}:require('${c.href}')`).join(',')}}`)
  sections.push('component.exports.partials = component.exports.partials || {}')
  sections.push(`component.exports.partials = {${partialParts.map(p => `${p.id}:${serialize(Ractive.parse(p.content))}`).join(',')}}`)
  sections.push('module.exports = Ractive.extend(component.exports)')

  const code = `${sections.join('\n')}\n`
  const map = null

  return { code, map }
}

export const toESM = ({ srcName, destName, parts }) => {
  // Unlike CJS where we just wrap and leave the indent intact, in ES we
  // mangle the source. The extra indents can throw you off when writing tests.
  const script = deindent((parts.script && parts.script.code) || '')
  const ast = parse(script, { sourceType: 'module' })
  const magicSource = new MagicString(script)
  const defaultExportResult = findNodeAfter(ast, 0, 'ExportDefaultDeclaration', base)

  if (!defaultExportResult) throw new Error('No default export found')

  const defaultExport = defaultExportResult.node
  const componentOptions = defaultExport.declaration
  const options = script.slice(componentOptions.start, componentOptions.end)

  // Start the sorcery
  const prefixParts = []
  const suffixParts = []

  prefixParts.push(`import Ractive from '@ractivejs/core'`)
  prefixParts.push(...parts.components.map(c => `import ${c.name} from '${c.module}'`))

  suffixParts.push(deindent(`var __INIT__ = ${options}`))
  if (parts.components.length) {
    suffixParts.push(`__INIT__.components = __INIT__.components || {}`)
  }
  suffixParts.push(...parts.components.map(c => `__INIT__.components.${c.name} = ${c.name}`))

  if (parts.template) suffixParts.push(`__INIT__.template = ${serialize(Ractive.parse(parts.template.code))}`)
  if (parts.style) suffixParts.push(`__INIT__.css = ${serialize(parts.style.code)}`)
  suffixParts.push(`export default Ractive.extend(__INIT__)`)

  const prefix = `${prefixParts.join('\n')}\n`
  const suffix = `\n${suffixParts.join('\n')}\n`

  magicSource.trim()
  magicSource.prepend(prefix)
  // TODO: Find a way for magic string to relocate the default export to
  // __INIT__ without losing it in the source map.
  magicSource.remove(defaultExport.start, defaultExport.end)
  magicSource.append(suffix)

  const code = magicSource.toString()

  // Because QUnit deepEqual gets thrown off by MagicString's extras on map
  const map = JSON.parse(magicSource.generateMap({ source: srcName, file: destName, includeContent: true }).toString())

  return { code, map }
}
