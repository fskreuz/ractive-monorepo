/* eslint-env node */
/* eslint-disable no-console */
import serialize from 'serialize-javascript'
import program from 'commander'
import Ractive from '@ractivejs/core'
import { toParts, toModule } from '@ractivejs/utils-component'
import { getViolations } from '@ractivejs/utils-a11y'
import { readFromStream, writeToStream, escapeUnicode } from './utils'
import * as scaffolds from './scaffolds'

program
  .command('parse')
  .description('Takes templates and emits its JSON/JS AST form.')
  .option('-x, --no-csp', 'Do not output expression functions.')
  .option('-d, --delimiters [pair]', 'Start and end delimiters for normal mustaches.')
  .option('-s, --static-delimiters [pair]', 'Start and end delimiters for static mustaches.')
  .option('-t, --triple-delimiters [pair]', 'Start and end delimiters for triple mustaches.')
  .option('-p, --static-triple-delimiters [pair]', 'Start and end delimiters for static triple mustaches.')
  .option('-u, --escape-unicode', 'Export non-ASCII characters in strings as UTF escapes.')
  .action(cmd => {
    const { csp, delimiters: d, staticDelimiters: s, tripleDelimiters: t, staticTripleDelimiters: p } = cmd
    const x = d => d ? d.split(' ') : void 0
    readFromStream(process.stdin).then(template => {
      const parsed = Ractive.parse(template, { delimiters: x(d), staticDelimiters: x(s), tripleDelimiters: x(t), staticTripleDelimiters: x(p), csp })
      const serialized = serialize(parsed)
      const escaped = cmd.escapeUnicode ? escapeUnicode(serialized) : serialized
      const newlined = `${escaped}\n`
      return writeToStream(process.stdout, newlined)
    }).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('parts')
  .description('Takes component files and emits its JSON parts form.')
  .action(() => {
    readFromStream(process.stdin).then(component => {
      return writeToStream(process.stdout, serialize(toParts(component)))
    }).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('module')
  .description('Takes the output of the parts command and emits a module.')
  .action(() => {
    readFromStream(process.stdin).then(partsString => {
      return writeToStream(process.stdout, toModule({ srcName: '', destName: '', parts: JSON.parse(partsString) }).code)
    }).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('sourcemap')
  .description('Takes the output of the parts command and emits a v3 source map.')
  .option('-s, --src-name <name>', 'The name of the source file.')
  .option('-f, --dest-name <name>', 'The name of the destination file.')
  .action(cmd => {
    const { srcName, destName } = cmd
    readFromStream(process.stdin).then(partsString => {
      const parts = JSON.parse(partsString)
      return writeToStream(process.stdout, JSON.stringify(toModule({ srcName, destName, parts }).map))
    }).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('scaffold <type>')
  .description('Emit a scaffold of give type. Valid values are: constructor, component, adaptor, decorator, easing, interpolator, event, transition.')
  .action(type => {
    const scaffoldContent = scaffolds[type]
    if (!scaffoldContent) throw new Error('Unknown scaffold type')
    writeToStream(process.stdout, scaffoldContent).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('a11y')
  .description('Takes component files and emits accessibility violations.')
  .action(() => {
    readFromStream(process.stdin).then(component => {
      const parts = toParts(component)
      const template = (parts.template && parts.template.code) || ''
      const templateByLine = template.split('\n')
      const warnings = getViolations(template).map(v => `[${v.line},${v.column}]${templateByLine[v.line - 1]}\n${v.message}`)

      return writeToStream(process.stdout, warnings.length ? `${warnings}\n` : '')
    }).catch(err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program.parse(process.argv)
